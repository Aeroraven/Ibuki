<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 9: 体积光照</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-9/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-9/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-9-体积光照"><a href="#Ifrit-v2-过程记录-9-体积光照" class="headerlink" title="Ifrit-v2 过程记录 9: 体积光照"></a>Ifrit-v2 过程记录 9: 体积光照</h1><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>T:图形学</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 8: 抗锯齿</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-8/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-8-抗锯齿"><a href="#Ifrit-v2-过程记录-8-抗锯齿" class="headerlink" title="Ifrit-v2 过程记录 8: 抗锯齿"></a>Ifrit-v2 过程记录 8: 抗锯齿</h1><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>T:图形学</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 7: 泛光</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-7/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-7/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-7-泛光"><a href="#Ifrit-v2-过程记录-7-泛光" class="headerlink" title="Ifrit-v2 过程记录 7: 泛光"></a>Ifrit-v2 过程记录 7: 泛光</h1><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>T:图形学</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 6: 有向距离场和全局光照</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-6/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-6/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-6-有向距离场和全局光照"><a href="#Ifrit-v2-过程记录-6-有向距离场和全局光照" class="headerlink" title="Ifrit-v2 过程记录 6: 有向距离场和全局光照"></a>Ifrit-v2 过程记录 6: 有向距离场和全局光照</h1><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>T:图形学</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
      <tag>T:数据结构</tag>
      
      <tag>L:Unreal Engine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 4: 环境光遮蔽</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-4/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-4-环境光遮蔽"><a href="#Ifrit-v2-过程记录-4-环境光遮蔽" class="headerlink" title="Ifrit-v2 过程记录 4: 环境光遮蔽"></a>Ifrit-v2 过程记录 4: 环境光遮蔽</h1><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>T:图形学</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 5: 虚拟几何体和GPU-Driven管线</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-5/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-5-虚拟几何体和GPU-Driven管线"><a href="#Ifrit-v2-过程记录-5-虚拟几何体和GPU-Driven管线" class="headerlink" title="Ifrit-v2 过程记录 5: 虚拟几何体和GPU-Driven管线"></a>Ifrit-v2 过程记录 5: 虚拟几何体和GPU-Driven管线</h1><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>T:图形学</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
      <tag>T:数据结构</tag>
      
      <tag>L:Unreal Engine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 3: Vulkan绘制流程</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-3/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-3-Vulkan绘制流程"><a href="#Ifrit-v2-过程记录-3-Vulkan绘制流程" class="headerlink" title="Ifrit-v2 过程记录 3: Vulkan绘制流程"></a>Ifrit-v2 过程记录 3: Vulkan绘制流程</h1><h2 id="1-第一个三角形"><a href="#1-第一个三角形" class="headerlink" title="1. 第一个三角形"></a>1. 第一个三角形</h2><h3 id="1-1-创建VkInstance"><a href="#1-1-创建VkInstance" class="headerlink" title="1.1 创建VkInstance"></a>1.1 创建VkInstance</h3><p>在Vulkan中，首先需要创建一个VkInstance。VkInstance是Vulkan的上下文，包含了Vulkan的所有信息。创建VkInstance前需要填上VkApplicationInfo结构体，包含了应用程序的名称、版本、Vulkan版本等信息。由于Ifrit-v2涉及一些1.3 Spec的核心特性，这里版本填Vulkan 1.3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkApplicationInfo appInfo  = &#123;&#125;;<br>appInfo.sType              = VK_STRUCTURE_TYPE_APPLICATION_INFO;<br>appInfo.pApplicationName   = <span class="hljs-string">&quot;&quot;</span>;<br>appInfo.applicationVersion = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.pEngineName        = <span class="hljs-string">&quot;Ifrit-v2&quot;</span>;<br>appInfo.engineVersion      = <span class="hljs-built_in">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>appInfo.apiVersion         = VK_API_VERSION_1_3;<br></code></pre></td></tr></table></figure><p>然后需要填上我们需要用到的Layers和Extensions。首先拿到由GLFW（此处由<code>ifrit.display.dll</code>抽象）窗口要求的Extensions。对于Layer，我们简单启用验证层即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (m_args.m_extensionGetter)<br>&#123;<br>    u32          extensionCountExtra = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** extensionsExtra     = m_args.<span class="hljs-built_in">m_extensionGetter</span>(&amp;extensionCountExtra);<br>    <span class="hljs-keyword">for</span> (u32 i = <span class="hljs-number">0</span>; i &lt; extensionCountExtra; i++)<br>    &#123;<br>        <span class="hljs-built_in">EnableExtension</span>(<span class="hljs-literal">true</span>, extensionsExtra[i], availableExtensions, targetExtensions);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (m_args.m_enableValidationLayer)<br>&#123;<br>    <span class="hljs-built_in">EnableExtension</span>(<span class="hljs-literal">true</span>, VK_EXT_DEBUG_UTILS_EXTENSION_NAME, availableExtensions, targetExtensions);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ext : m_instanceExtension)<br>&#123;<br>    <span class="hljs-built_in">EnableExtension</span>(<span class="hljs-literal">true</span>, ext, availableExtensions, targetExtensions);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后填上我们的<code>VkInstanceCreateInfo</code>结构体，创建VkInstance。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreateInstance</span>(&amp;instanceCI, <span class="hljs-literal">nullptr</span>, &amp;m_instance), <span class="hljs-string">&quot;Failed to create Vulkan instance&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-2-获取物理设备和队列族-Queue-Familiy"><a href="#1-2-获取物理设备和队列族-Queue-Familiy" class="headerlink" title="1.2 获取物理设备和队列族(Queue Familiy)"></a>1.2 获取物理设备和队列族(Queue Familiy)</h3><p>在建立VkInstance后，我们需要获取物理设备。物理设备是Vulkan的核心，包含了Vulkan的所有信息。我们可以通过<code>vkEnumeratePhysicalDevices</code>函数获取物理设备列表。这里我们暂时希望选择一个独立显卡（Discrete GPU），如果没有则选择集成显卡（Integrated GPU）。如果没有，则返回错误。相同情况则选择支持分辨率最高的GPU。完成后，我们把物理设备的属性信息填入<code>m_phyDeviceProperties</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u32 physicalDeviceCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(m_instance, &amp;physicalDeviceCount, <span class="hljs-literal">nullptr</span>),<br>    <span class="hljs-string">&quot;Failed to enumerate physical devices&quot;</span>);<br><span class="hljs-function">Vec&lt;VkPhysicalDevice&gt; <span class="hljs-title">physicalDevices</span><span class="hljs-params">(physicalDeviceCount)</span></span>;<br><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkEnumeratePhysicalDevices</span>(m_instance, &amp;physicalDeviceCount, physicalDevices.<span class="hljs-built_in">data</span>()),<br>    <span class="hljs-string">&quot;Failed to enumerate physical devices&quot;</span>);<br><br>VkPhysicalDevice bestDevice = VK_NULL_HANDLE;<br><span class="hljs-type">int</span>              bestScore  = <span class="hljs-number">0</span>;<br>String           bestName;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> device : physicalDevices)<br>&#123;<br>    String name;<br>    <span class="hljs-type">int</span>    score = <span class="hljs-built_in">PhysicalDeviceRanking</span>(device, &amp;name);<br>    <span class="hljs-keyword">if</span> (score &gt; bestScore)<br>    &#123;<br>        bestScore  = score;<br>        bestDevice = device;<br>        bestName   = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">vkGetPhysicalDeviceProperties</span>(m_physicalDevice, &amp;m_phyDeviceProperties);<br></code></pre></td></tr></table></figure><p>队列是Vulkan命令提交的目标对象。Vulkan将Command Buffer提交到队列，队列会将Command Buffer提交到GPU执行。Vulkan的队列是异步的，提交后不会等待GPU执行完成。一个物理设备包含不同类型的队列，每一组队列都包含相同的功能子集，这些队列组成了一个队列族。我们可以通过<code>vkGetPhysicalDeviceQueueFamilyProperties</code>函数获取物理设备的队列族属性。目前我们先拿到所有队列族，对于功能的处理，我们后续再进行考虑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u32 queueFamilyCount = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(bestDevice, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-function">Vec&lt;VkQueueFamilyProperties&gt; <span class="hljs-title">queueFamilies</span><span class="hljs-params">(queueFamilyCount)</span></span>;<br><span class="hljs-built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(bestDevice, &amp;queueFamilyCount, queueFamilies.<span class="hljs-built_in">data</span>());<br><span class="hljs-keyword">for</span> (u32 i = <span class="hljs-number">0</span>; i &lt; queueFamilyCount; i++)<br>&#123;<br>    DeviceQueueInfo::DeviceQueueFamily family;<br>    family.m_familyIndex = i;<br>    family.m_queueCount  = queueFamilies[i].queueCount;<br>    family.m_capability  = queueFamilies[i].queueFlags;<br>    m_queueInfo.m_queueFamilies.<span class="hljs-built_in">push_back</span>(family);<br>&#125;<br><br><span class="hljs-comment">// Queue Creation</span><br>Vec&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;<br>Vec&lt;Vec&lt;<span class="hljs-type">float</span>&gt;&gt;              queuePriorities;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> family : m_queueInfo.m_queueFamilies)<br>&#123;<br>    VkDeviceQueueCreateInfo queueCreateInfo = &#123;&#125;;<br>    queueCreateInfo.sType                   = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;<br>    queueCreateInfo.queueFamilyIndex        = family.m_familyIndex;<br>    queueCreateInfo.queueCount              = family.m_queueCount;<br>    queuePriorities.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-type">float</span>&gt;(family.m_queueCount, <span class="hljs-number">1.0f</span>));<br>    queueCreateInfo.pQueuePriorities = queuePriorities.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">data</span>();<br>    queueCreateInfos.<span class="hljs-built_in">push_back</span>(queueCreateInfo);<br>&#125;<br></code></pre></td></tr></table></figure><p>队列有3种类型：图形队列（Graphics Queue）、计算队列（Compute Queue）和传输队列（Transfer Queue）。虽然一个队列族可以包含多种类型的队列，但我们在这里只需要图形队列。我们可以通过<code>VK_QUEUE_GRAPHICS_BIT</code>来判断一个队列是否是图形队列。同样地，我们获取计算队列（用于Async Compute）和传输队列，虽然现在还用不到，但我们先把他们存起来 &gt;_&lt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (queueFamilies[i].queueFlags &amp; VK_QUEUE_GRAPHICS_BIT)<br>&#123;<br>    m_queueInfo.m_graphicsQueues.<span class="hljs-built_in">push_back</span>(queue);<br>&#125;<br><span class="hljs-keyword">if</span> (queueFamilies[i].queueFlags &amp; VK_QUEUE_COMPUTE_BIT)<br>&#123;<br>    m_queueInfo.m_computeQueues.<span class="hljs-built_in">push_back</span>(queue);<br>&#125;<br><span class="hljs-keyword">if</span> (queueFamilies[i].queueFlags &amp; VK_QUEUE_TRANSFER_BIT)<br>&#123;<br>    m_queueInfo.m_transferQueues.<span class="hljs-built_in">push_back</span>(queue);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-创建Logical-Device"><a href="#1-3-创建Logical-Device" class="headerlink" title="1.3 创建Logical Device"></a>1.3 创建Logical Device</h3><p>逻辑设备是用于与物理设备交互的抽象。 同样地，我们填上我们的应用程序（当前的Logical Device）需要的功能和扩展，以及要使用的队列族。我们需要使用<code>vkCreateDevice</code>函数创建逻辑设备。我们用到了一些Vulkan 1.2以后的特性，例如Bindless所需要的描述符索引 （Descriptor Indexing）和动态渲染等。我们将这些特性插入到<code>pNext</code>中去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkDeviceCreateInfo deviceCI   = &#123;&#125;;<br>deviceCI.sType                = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;<br>deviceCI.queueCreateInfoCount = <span class="hljs-built_in">SizeCast</span>&lt;u32&gt;(queueCreateInfos.<span class="hljs-built_in">size</span>());<br>deviceCI.pQueueCreateInfos    = queueCreateInfos.<span class="hljs-built_in">data</span>();<br>deviceCI.pEnabledFeatures     = &amp;deviceFeatures;<br>deviceCI.pNext                = &amp;deviceFeatures12;<br>deviceCI.enabledExtensionCount   = <span class="hljs-built_in">SizeCast</span>&lt;u32&gt;(tarGetDeviceExtensions.<span class="hljs-built_in">size</span>());<br>deviceCI.ppEnabledExtensionNames = tarGetDeviceExtensions.<span class="hljs-built_in">data</span>();<br>deviceCI.enabledLayerCount   = <span class="hljs-built_in">SizeCast</span>&lt;u32&gt;(targetLayersDevice.<span class="hljs-built_in">size</span>());<br>deviceCI.ppEnabledLayerNames = targetLayersDevice.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure><p>这里的 <code>pNext</code>是组成了一个链表的结构体。我们可以在这个链表中插入我们需要的特性。例如组装Mesh Shader和纹理的64位整数原子访问。当然在此之前，我们需要添加Instance层级的扩展，然后加到<code>ppEnabledExtensionNames</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">meshShaderFeatures.sType      = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;<br>meshShaderFeatures.taskShader = VK_TRUE;<br>meshShaderFeatures.meshShader = VK_TRUE;<br>meshShaderFeatures.pNext      = &amp;shaderImageAtomicInt64Features;<br><br>shaderImageAtomicInt64Features.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;<br>shaderImageAtomicInt64Features.shaderImageInt64Atomics = VK_TRUE;<br></code></pre></td></tr></table></figure><p>填完后，我们就可以创建Logical Device了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreateDevice</span>(bestDevice, &amp;deviceCI, <span class="hljs-literal">nullptr</span>, &amp;m_device), <span class="hljs-string">&quot;Failed to create logical device&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-4-创建Swapchain"><a href="#1-4-创建Swapchain" class="headerlink" title="1.4 创建Swapchain"></a>1.4 创建Swapchain</h3><p>Vulkan是一个平台无关的API，为了将图像显示到屏幕上，我们需要使用WSI（Window System Integration）扩展。这里使用过<code>VK_KHR_Surface</code>扩展提供的Surface来完成这一个步骤。目前我们只考虑Windows，这部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m_hInstance = m_context-&gt;<span class="hljs-built_in">GetArgs</span>().m_win<span class="hljs-number">32.</span>m_hInstance;<br>m_hWnd      = m_context-&gt;<span class="hljs-built_in">GetArgs</span>().m_win<span class="hljs-number">32.</span>m_hWnd;<br>VkWin32SurfaceCreateInfoKHR surfaceCI&#123;&#125;;<br>surfaceCI.sType     = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;<br>surfaceCI.hinstance = (HINSTANCE)m_hInstance;<br>surfaceCI.hwnd      = (HWND)m_hWnd;<br><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreateWin32SurfaceKHR</span>(m_context-&gt;<span class="hljs-built_in">GetInstance</span>(), &amp;surfaceCI, <span class="hljs-literal">nullptr</span>, &amp;m_surface),<br>    <span class="hljs-string">&quot;Failed to create window surface&quot;</span>);<br></code></pre></td></tr></table></figure><p>之后我们考虑创建Swapchain。Swapchain是Vulkan中用于交换图像的对象。大致过程把图像画到Swapchain上，然后交换到屏幕上。我们需要使用<code>vkCreateSwapchainKHR</code>函数创建Swapchain。我们需要填上Swapchain的创建信息，包括图像格式、图像数量、交换链的宽高等信息。我们可以通过<code>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code>函数获取物理设备的表面能力。目前我们的默认配置如下：</p><ul><li>图像格式：默认<code>VK_FORMAT_B8G8R8A8_SRGB</code>优先</li><li>Present模式：默认<code>VK_PRESENT_MODE_MAILBOX_KHR</code>否则<code>VK_PRESENT_MODE_FIFO_KHR</code><ul><li><code>VK_PRESENT_MODE_FIFO_KHR</code>: 显示器从队列中获取图像并显示，程序在尾部插入图像。队列满则等待。</li><li><code>VK_PRESENT_MODE_MAILBOX_KHR</code>: 显示器从队列中获取图像并显示，程序在头部插入图像。队列满则丢弃图像写入。</li></ul></li><li>图像数量：默认由程序的<code>m_expectedSwapchainImageCount</code>决定，至少2个保证能够InFlight（CPU处理当前帧，GPU处理上一帧）交换。</li><li>队列族：默认图形队列族</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkSwapchainCreateInfoKHR swapchainCI&#123;&#125;;<br>swapchainCI.sType            = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;<br>swapchainCI.surface          = m_surface;<br>swapchainCI.minImageCount    = m_backbufferCount;<br>swapchainCI.imageFormat      = m_preferredSurfaceFormat.format;<br>swapchainCI.imageColorSpace  = m_preferredSurfaceFormat.colorSpace;<br>swapchainCI.imageExtent      = m_extent;<br>swapchainCI.imageArrayLayers = <span class="hljs-number">1</span>;<br>swapchainCI.imageUsage       = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;<br><br>swapchainCI.imageSharingMode      = VK_SHARING_MODE_EXCLUSIVE;<br>swapchainCI.queueFamilyIndexCount = <span class="hljs-number">0</span>;<br>swapchainCI.pQueueFamilyIndices   = <span class="hljs-literal">nullptr</span>;<br><br>swapchainCI.preTransform   = m_supportDetails.capabilities.currentTransform;<br>swapchainCI.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;<br>swapchainCI.presentMode    = m_preferredPresentMode;<br>swapchainCI.clipped        = VK_TRUE;<br>swapchainCI.oldSwapchain   = VK_NULL_HANDLE;<br><br><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreateSwapchainKHR</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), &amp;swapchainCI, <span class="hljs-literal">nullptr</span>, &amp;m_swapchain),<br>    <span class="hljs-string">&quot;Failed to create swapchain&quot;</span>);<br></code></pre></td></tr></table></figure><p>之后，我们获取Swapchain的图像，然后为这些图像创建ImageView（定义了访问这些图像的方式）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">u32 imageCount;<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), m_swapchain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);<br>m_images.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-built_in">vkGetSwapchainImagesKHR</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), m_swapchain, &amp;imageCount, m_images.<span class="hljs-built_in">data</span>());<br><br><span class="hljs-comment">// Create image views</span><br>m_imageViews.<span class="hljs-built_in">resize</span>(imageCount);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(imageCount); i++)<br>&#123;<br>    VkImageViewCreateInfo imageViewCI&#123;&#125;;<br>    imageViewCI.sType                           = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;<br>    imageViewCI.image                           = m_images[i];<br>    imageViewCI.viewType                        = VK_IMAGE_VIEW_TYPE_2D;<br>    imageViewCI.format                          = m_preferredSurfaceFormat.format;<br>    imageViewCI.components.r                    = VK_COMPONENT_SWIZZLE_IDENTITY;<br>    imageViewCI.components.g                    = VK_COMPONENT_SWIZZLE_IDENTITY;<br>    imageViewCI.components.b                    = VK_COMPONENT_SWIZZLE_IDENTITY;<br>    imageViewCI.components.a                    = VK_COMPONENT_SWIZZLE_IDENTITY;<br>    imageViewCI.subresourceRange.aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT;<br>    imageViewCI.subresourceRange.baseMipLevel   = <span class="hljs-number">0</span>;<br>    imageViewCI.subresourceRange.levelCount     = <span class="hljs-number">1</span>;<br>    imageViewCI.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;<br>    imageViewCI.subresourceRange.layerCount     = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreateImageView</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), &amp;imageViewCI, <span class="hljs-literal">nullptr</span>, &amp;m_imageViews[i]),<br>        <span class="hljs-string">&quot;Failed to create image view&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-创建Pipeline和动态渲染"><a href="#1-5-创建Pipeline和动态渲染" class="headerlink" title="1.5 创建Pipeline和动态渲染"></a>1.5 创建Pipeline和动态渲染</h3><p>一个Graphics Pipeline包括了下面几个组成成分：</p><ul><li>VkPipelineInputAssemblyStateCreateInfo: 输入装配状态，三角形&#x2F;点或者线</li><li>VkPipelineViewportStateCreateInfo：视口&#x2F;Scissor状态，视口&#x2F;Scissor的大小和数量</li><li>VkPipelineMultisampleStateCreateInfo：多重采样状态，MSAA的级别</li><li>VkPipelineRasterizationStateCreateInfo：光栅化状态，线宽，剔除状态，Polygon模式</li><li>VkPipelineColorBlendStateCreateInfo：颜色混合状态，颜色混合的方式</li><li>VkPipelineDepthStencilStateCreateInfo：深度模板状态，深度测试，模板测试</li><li>VkPipelineLayoutCreateInfo：管线布局，描述符集布局和Push Constant的布局</li></ul><blockquote><p>当然，指定为Dynamic State后可以随意填写。</p></blockquote><p>对于动态渲染，我们填VkPipelineRenderingCreateInfo，其中描述好这个Graphics Pipeline的渲染目标（格式）、深度和模板格式的信息，然后将信息写入当前PipelineCI的<code>pNext</code>指针中。这种情况下我们PipelineCI的<code>renderPass</code>和<code>subpass</code>都设置为VK_NULL_HANDLE和0。我们在创建Pipeline时，使用<code>vkCreateGraphicsPipelines</code>函数创建Pipeline。</p><p>Pipeline的创建会编译Shader，因此有性能代价，为此Vulkan引入了Pipeline Cache来复用那些已经被创建的Pipelines。</p><blockquote><p>实现上，Ifrit-v2为每一个Pipeline都计算了一个Hash值（冲突fallback到比较），因此看起来不会有新建Pipeline的开销。虽然项目也加了Vulkan自己的Pipeline Cache.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreatePipelineCache</span>(device, &amp;cacheCI, <span class="hljs-literal">nullptr</span>, &amp;cache), <span class="hljs-string">&quot;Failed to create pipeline cache&quot;</span>);<br><span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">vkCreateGraphicsPipelines</span>(device, cache, <span class="hljs-number">1</span>, &amp;pipelineCI, <span class="hljs-literal">nullptr</span>, &amp;m_pipeline);<br><span class="hljs-built_in">vkrVulkanAssert</span>(res, <span class="hljs-string">&quot;Failed to create graphics pipeline&quot;</span>);<br><br><span class="hljs-keyword">if</span> (!cacheExists)<br>&#123;<br>    <span class="hljs-type">size_t</span> cacheSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">vkrVulkanAssert</span>(<br>        <span class="hljs-built_in">vkGetPipelineCacheData</span>(device, cache, &amp;cacheSize, <span class="hljs-literal">nullptr</span>), <span class="hljs-string">&quot;Failed to get pipeline cache data size&quot;</span>);<br>    cacheData.<span class="hljs-built_in">resize</span>(cacheSize);<br>    <span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkGetPipelineCacheData</span>(device, cache, &amp;cacheSize, cacheData.<span class="hljs-built_in">data</span>()),<br>        <span class="hljs-string">&quot;Failed to get pipeline cache data&quot;</span>);<br><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">cacheFile</span><span class="hljs-params">(cachePath, std::ios::binary)</span></span>;<br>    cacheFile.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(cacheData.<span class="hljs-built_in">data</span>()), cacheSize);<br>    cacheFile.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-1-虽然没使用的RenderPass和SubPass"><a href="#1-5-1-虽然没使用的RenderPass和SubPass" class="headerlink" title="1.5.1 虽然没使用的RenderPass和SubPass"></a>1.5.1 虽然没使用的RenderPass和SubPass</h4><p>传统的RenderPass流程实际上做了隐式的Layout转换,而新的动态渲染流程则不需要了,所有都得自己写。与此同时,动态渲染的引入也废弃了VkFrameBuffer这一个概念，但是Dynamic Rendering仍然有自己的缺陷。</p><blockquote><p>VK_KHR_dynamic_rendering显然带来了更好的开发体验和易用性，那么代价是什么？显然这带来了运行时的校验开销。这包括检 RenderPass参数有效性、Pipeline 与 RenderPass 的隐式关联的有效性等，这些校验必然需要一定的额外开销。使用Dynamic Rendering需要在易用性和性能之间进行权衡。[1]</p></blockquote><p>RenderPass 可以看作是一次渲染的抽象描述，包含了渲染的目标、格式、Attachment等信息。每一个RenderPass包含了多个子步骤，每一个子步骤称为Subpass。Subpass可以看作是RenderPass的一个阶段，每一个Subpass可以有自己的输入和输出Attachment。</p><p>SubPass在TBDR上还是有优点的：</p><blockquote><p>Subpasses are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance. [2]</p></blockquote><blockquote><p>Tile-based renderers, for example, can take advantage of tile memory, which being on chip is decisively faster than external memory, potentially saving a considerable amount of bandwidth. [3]</p></blockquote><h3 id="1-6-创建Command-Buffer"><a href="#1-6-创建Command-Buffer" class="headerlink" title="1.6 创建Command Buffer"></a>1.6 创建Command Buffer</h3><p>Command Buffer是Vulkan中用于记录命令的对象。我们可以通过<code>vkAllocateCommandBuffers</code>函数创建Command Buffer。我们需要填上Command Buffer的创建信息，包括Command Buffer的类型、池等信息。我们可以通过<code>vkCreateCommandPool</code>函数创建Command Pool。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VkCommandPoolCreateInfo poolCI&#123;&#125;;<br>poolCI.sType            = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;<br>poolCI.queueFamilyIndex = m_queueFamily;<br>poolCI.flags            = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;<br><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkCreateCommandPool</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), &amp;poolCI, <span class="hljs-literal">nullptr</span>, &amp;m_commandPool),<br>    <span class="hljs-string">&quot;Failed to create command pool&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然我们可以每一帧都<code>vkAllocateCommandBuffers</code>，或者复用第K帧前的Command Buffer（只要不在GPU端使用即可）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (m_AvailableCommandBuffers.<span class="hljs-built_in">empty</span>())<br>&#123;<br>    VkCommandBufferAllocateInfo bufferAI&#123;&#125;;<br>    bufferAI.sType              = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;<br>    bufferAI.commandPool        = m_commandPool;<br>    bufferAI.level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY;<br>    bufferAI.commandBufferCount = <span class="hljs-number">1</span>;<br><br>    VkCommandBuffer buffer;<br>    <span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkAllocateCommandBuffers</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), &amp;bufferAI, &amp;buffer),<br>        <span class="hljs-string">&quot;Failed to allocate command buffer&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;CommandBuffer&gt;(m_context, buffer, m_queueFamily);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> cmdBuf = std::<span class="hljs-built_in">move</span>(m_AvailableCommandBuffers.<span class="hljs-built_in">back</span>());<br>    m_AvailableCommandBuffers.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> cmdBuf;<br>&#125;<br></code></pre></td></tr></table></figure><p>Command Buffer的执行由<code>vkQueueSubmit</code>函数提交到队列。我们需要填上Command Buffer的提交信息，包括Command Buffer的数量、信号量等信息。我们可以通过<code>vkQueuePresentKHR</code>函数将图像交换到屏幕上。这里同步使用了Timeline Semaphore来进行（两个优势：具备Fence和Semaphore的特性，且在多个队列同步上不会出现组合数级别的Semaphore）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> VkSubmitInfo submitInfo&#123;&#125;;<br>submitInfo.sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO;<br>submitInfo.waitSemaphoreCount   = <span class="hljs-built_in">SizeCast</span>&lt;<span class="hljs-type">int</span>&gt;(waitSemaphoreHandles.<span class="hljs-built_in">size</span>());<br>submitInfo.pWaitSemaphores      = waitSemaphoreHandles.<span class="hljs-built_in">data</span>();<br>submitInfo.pWaitDstStageMask    = waitStages.<span class="hljs-built_in">data</span>();<br>submitInfo.commandBufferCount   = <span class="hljs-number">1</span>;<br>submitInfo.pCommandBuffers      = &amp;commandBuffer;<br>submitInfo.signalSemaphoreCount = <span class="hljs-built_in">SizeCast</span>&lt;<span class="hljs-type">int</span>&gt;(signalSemaphores.<span class="hljs-built_in">size</span>());<br>submitInfo.pSignalSemaphores    = signalSemaphores.<span class="hljs-built_in">data</span>();<br><br>VkTimelineSemaphoreSubmitInfo timelineInfo&#123;&#125;;<br>timelineInfo.sType                     = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;<br>timelineInfo.waitSemaphoreValueCount   = <span class="hljs-built_in">SizeCast</span>&lt;<span class="hljs-type">int</span>&gt;(waitValues.<span class="hljs-built_in">size</span>());<br>timelineInfo.pWaitSemaphoreValues      = waitValues.<span class="hljs-built_in">data</span>();<br>timelineInfo.signalSemaphoreValueCount = <span class="hljs-built_in">SizeCast</span>&lt;<span class="hljs-type">int</span>&gt;(signalValues.<span class="hljs-built_in">size</span>());<br>timelineInfo.pSignalSemaphoreValues    = signalValues.<span class="hljs-built_in">data</span>();<br><br>submitInfo.pNext = &amp;timelineInfo;<br>VkFence vfence   = VK_NULL_HANDLE;<br><span class="hljs-keyword">if</span> (fence)<br>&#123;<br>    vfence = fence;<br>&#125;<br><span class="hljs-built_in">vkrVulkanAssert</span>(<span class="hljs-built_in">vkQueueSubmit</span>(m_queue, <span class="hljs-number">1</span>, &amp;submitInfo, vfence), <span class="hljs-string">&quot;Failed to submit command buffer&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-7-动态渲染的命令缓冲"><a href="#1-7-动态渲染的命令缓冲" class="headerlink" title="1.7 动态渲染的命令缓冲"></a>1.7 动态渲染的命令缓冲</h3><p>虽然没了VkFrameBuffer，但是我们还需要在开始Dynamic Rendering前先给我们的Attachment设定是要先Clear还是Load。以及Rendering的范围是多大。填完后开始Dynamic Rendering。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> attachment : m_colorAttachments)<br>&#123;<br>    VkClearValue clearValue;<br>    clearValue.color.float32[<span class="hljs-number">0</span>] = attachment-&gt;<span class="hljs-built_in">GetClearValue</span>().m_color[<span class="hljs-number">0</span>];<br>    clearValue.color.float32[<span class="hljs-number">1</span>] = attachment-&gt;<span class="hljs-built_in">GetClearValue</span>().m_color[<span class="hljs-number">1</span>];<br>    clearValue.color.float32[<span class="hljs-number">2</span>] = attachment-&gt;<span class="hljs-built_in">GetClearValue</span>().m_color[<span class="hljs-number">2</span>];<br>    clearValue.color.float32[<span class="hljs-number">3</span>] = attachment-&gt;<span class="hljs-built_in">GetClearValue</span>().m_color[<span class="hljs-number">3</span>];<br><br>    ...<br><br>    VkRenderingAttachmentInfoKHR attachmentInfo&#123;&#125;;<br>    attachmentInfo.sType      = VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR;<br>    attachmentInfo.clearValue = clearValue;<br>    attachmentInfo.loadOp     = loadOp;<br>    <br>    ...<br><br>    colorAttachmentInfos.<span class="hljs-built_in">push_back</span>(attachmentInfo);<br>&#125;<br>VkRect2D renderArea;<br>renderArea.extent = &#123; m_renderArea.width, m_renderArea.height &#125;;<br>renderArea.offset = &#123; m_renderArea.x, m_renderArea.y &#125;;<br><br>VkRenderingInfo renderingInfo&#123;&#125;;<br>renderingInfo.sType                = VK_STRUCTURE_TYPE_RENDERING_INFO;<br>renderingInfo.renderArea           = renderArea;<br>renderingInfo.layerCount           = <span class="hljs-number">1</span>;<br>renderingInfo.colorAttachmentCount = <span class="hljs-built_in">SizeCast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(m_colorAttachments.<span class="hljs-built_in">size</span>());<br>renderingInfo.pColorAttachments    = colorAttachmentInfos.<span class="hljs-built_in">data</span>();<br>renderingInfo.pDepthAttachment     = m_depthStencilAttachment ? &amp;depthAttachmentInfo : <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-built_in">vkCmdBeginRendering</span>(cmdraw, &amp;renderingInfo);<br></code></pre></td></tr></table></figure><p>当然，还需要将上一步的Pipeline和Descriptor Set绑定到Command Buffer上。我们可以通过<code>vkCmdBindPipeline</code>函数绑定Pipeline，通过<code>vkCmdBindDescriptorSets</code>函数绑定Descriptor Set。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vkCmdBindPipeline</span>(<br>            m_commandBuffer-&gt;<span class="hljs-built_in">GetCommandBuffer</span>(), VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline-&gt;<span class="hljs-built_in">GetPipeline</span>());<br>...<br><span class="hljs-keyword">auto</span> bindlessSet = m_descriptorManager-&gt;<span class="hljs-built_in">GetBindlessSet</span>();<br><span class="hljs-built_in">vkCmdBindDescriptorSets</span>(<br>            cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline-&gt;<span class="hljs-built_in">GetLayout</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;bindlessSet, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>如果设定了Dynamic State，则这时候需要指定这些State的值，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">exfun.<span class="hljs-built_in">p_vkCmdSetLogicOpEnableEXT</span>(cmd, m_logicalOpEnable);<br>exfun.<span class="hljs-built_in">p_vkCmdSetLogicOpEXT</span>(cmd, m_logicOp);<br>exfun.<span class="hljs-built_in">p_vkCmdSetStencilTestEnable</span>(cmd, m_stencilEnable);<br>exfun.<span class="hljs-built_in">p_vkCmdSetStencilOp</span>(cmd, m_stencilOp.faceMask, m_stencilOp.failOp, m_stencilOp.passOp,<br>    m_stencilOp.depthFailOp, m_stencilOp.compareOp);<br></code></pre></td></tr></table></figure><p>至于要如何绘制，由于方法多样（如Multi Indirect Draw），这里封装的Graphics Pass就不对此抽象。用户侧声明最终绘制方式。至于State，则交由上层RDG管理（在<code>ifrit.runtime.dll</code>中），Vulkan对RHI的实现这里仅做State的Tracking。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (m_recordFunction)<br>&#123;<br>    <span class="hljs-built_in">m_recordFunction</span>(&amp;m_passContext);<br>&#125;<br><br>renderTarget-&gt;<span class="hljs-built_in">EndRendering</span>(m_commandBuffer);<br></code></pre></td></tr></table></figure><h3 id="1-8-在屏幕上显示第一个三角形"><a href="#1-8-在屏幕上显示第一个三角形" class="headerlink" title="1.8 在屏幕上显示第一个三角形?"></a>1.8 在屏幕上显示第一个三角形?</h3><p>最后，我们需要将图像交换到屏幕上。我们可以通过<code>vkQueuePresentKHR</code>函数将图像交换到屏幕上。我们需要填上交换的信息，包括交换链、图像索引等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>VkPresentInfoKHR presentInfo&#123;&#125;;<br>presentInfo.sType              = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;<br>presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;<br>presentInfo.pWaitSemaphores    = &amp;m_renderingFinishSemaphores[m_currentFrame];<br>presentInfo.swapchainCount     = <span class="hljs-number">1</span>;<br>presentInfo.pSwapchains        = &amp;m_swapchain;<br>presentInfo.pImageIndices      = &amp;m_imageIndex;<br><br><span class="hljs-built_in">vkQueuePresentKHR</span>(m_presentQueue, &amp;presentInfo);<br>m_currentFrame = (m_currentFrame + <span class="hljs-number">1</span>) % m_backbufferCount;<br></code></pre></td></tr></table></figure><p>当然还要决定当前帧的图像要画到哪里，所以在帧开始前我们需要获取当前帧的图像索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vkWaitForFences</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), <span class="hljs-number">1</span>, &amp;m_inFlightFences[m_currentFrame], VK_TRUE, UINT64_MAX);<br><span class="hljs-built_in">vkResetFences</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), <span class="hljs-number">1</span>, &amp;m_inFlightFences[m_currentFrame]);<br>u32 imageIndex;<br><span class="hljs-built_in">vkAcquireNextImageKHR</span>(m_context-&gt;<span class="hljs-built_in">GetDevice</span>(), m_swapchain, UINT64_MAX,<br>    m_imageAvailableSemaphores[m_currentFrame], VK_NULL_HANDLE, &amp;imageIndex);<br>m_imageIndex = imageIndex;<br><span class="hljs-keyword">return</span> imageIndex;<br></code></pre></td></tr></table></figure><p>至此，就可以在屏幕上显示第一个三角形了（对于Buffer的处理后续再说）。</p><h2 id="2-Resources和Descriptors"><a href="#2-Resources和Descriptors" class="headerlink" title="2. Resources和Descriptors"></a>2. Resources和Descriptors</h2><p>TODO </p><h2 id="额外参考文献"><a href="#额外参考文献" class="headerlink" title="额外参考文献"></a>额外参考文献</h2><ul><li>[1] zhuanlan.zhihu.com&#x2F;p&#x2F;555509777</li><li>[2] <a href="http://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes">http://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes</a></li><li>[3] <a href="http://docs.vulkan.org/samples/latest/samples/performance/subpasses/README.html">http://docs.vulkan.org/samples/latest/samples/performance/subpasses/README.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
      <tag>T:操作系统</tag>
      
      <tag>L:Vulkan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 2: SIMD和CPU多线程</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-2/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-2-SIMD和CPU多线程"><a href="#Ifrit-v2-过程记录-2-SIMD和CPU多线程" class="headerlink" title="Ifrit-v2 过程记录 2: SIMD和CPU多线程"></a>Ifrit-v2 过程记录 2: SIMD和CPU多线程</h1><h2 id="1-MT-SIMD-软光栅流程"><a href="#1-MT-SIMD-软光栅流程" class="headerlink" title="1. MT-SIMD 软光栅流程"></a>1. MT-SIMD 软光栅流程</h2><h3 id="1-1-自旋锁和屏障"><a href="#1-1-自旋锁和屏障" class="headerlink" title="1.1 自旋锁和屏障"></a>1.1 自旋锁和屏障</h3><p>在 Ifrit-v2 中，整体流程和CUDA版本几乎一致，因此重复过程略去。CUDA版本中Kernel执行顺序在Stream中严格按照顺序执行，但CPU中需要考虑同步问题。因此整体多线程同步流程如下：</p><ul><li>所有Worker开始某个阶段的工作</li><li>当前Worker完成后，将自身状态切换到下一阶段等待（等待所有Worker）</li><li>当所有Worker完成后，所有Worker开始下一阶段的工作</li></ul><p>这个Barrier显式地由Master进行控制。如果所有Worker都期望进行下一阶段，下方<code>allOnBarrier</code>将通过测试，并放行所有Worker线程到下一阶段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TileRasterRenderer::statusTransitionBarrier2</span><span class="hljs-params">(TileRasterStage waitOn, TileRasterStage proceedTo)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">bool</span> allOnBarrier = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; worker : workers)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> expected = waitOn;<br>            allOnBarrier  = allOnBarrier<br>                &amp;&amp; (worker-&gt;status.<span class="hljs-built_in">compare_exchange_weak</span>(expected, proceedTo, std::memory_order::acq_rel)<br>                    || (expected &gt;= proceedTo));<br>        &#125;<br>        <span class="hljs-keyword">auto</span> expected = waitOn;<br>        allOnBarrier  = allOnBarrier<br>            &amp;&amp; (selfOwningWorker-&gt;status.<span class="hljs-built_in">compare_exchange_weak</span>(expected, proceedTo, std::memory_order::acq_rel)<br>                || (expected &gt;= proceedTo));<br>        <span class="hljs-keyword">if</span> (allOnBarrier)<br>            <span class="hljs-keyword">break</span>;<br>        std::this_thread::<span class="hljs-built_in">yield</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Tiling和原子获取"><a href="#1-2-Tiling和原子获取" class="headerlink" title="1.2 Tiling和原子获取"></a>1.2 Tiling和原子获取</h3><p>同样地，光栅化等阶段还是以Tile为单位进行。因此对于每一个阶段，维护一个原子的Tile计数，表示待处理的Tile数量。每一个阶段的某个Worker如果发现Tile计数使用完毕，则准备转入下一个状态。对于CPU，一个Worker负责一个Tile从光栅化到像素阶段的所有工作，而不是像CUDA一样同步执行。（尽可能靠近移动端TBR的实现，减少同步开销）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TileRasterWorker::tiledProcessing</span><span class="hljs-params">(TileRasterRenderer* renderer, <span class="hljs-type">bool</span> clearDepth)</span> IFRIT_AP_NOTHROW</span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (reqDeterministic)<br>    &#123;<br>        <span class="hljs-keyword">while</span> ((curTile = renderer-&gt;<span class="hljs-built_in">fetchUnresolvedTileRaster</span>()) &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            coverQueueLocal.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-built_in">rasterizationSingleTile</span>(renderer, curTile);<br>            <span class="hljs-built_in">sortOrderProcessingSingleTile</span>(renderer, curTile);<br>            <span class="hljs-built_in">fragmentProcessingSingleTile</span>(renderer, clearDepth, curTile);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ...<br>    &#125;<br>    status.<span class="hljs-built_in">store</span>(TileRasterStage::FRAGMENT_SHADING_SYNC, std::memory_order::relaxed);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-3-SIMD和AoS转SoA"><a href="#1-3-SIMD和AoS转SoA" class="headerlink" title="1.3 SIMD和AoS转SoA"></a>1.3 SIMD和AoS转SoA</h3><p>使用SIMD指令一次性同时处理4&#x2F;8个对应的对象。以片元着色阶段，对于Tile Accept和Sub Tile Accept的所有(Sub)Tiles，可以使用SIMD一次性执行8个像素的重心插值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> IFRIT_USE_SIMD_256</span><br>    __m256i dxId256 = _mm256_add_epi32(_mm256_set1_epi32(i), dxId256T);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _MSC_VER</span><br>    __m256i dx256T1 = _mm256_and_epi32(dxId256,<br>        _mm256_set1_epi32(<span class="hljs-number">0xf</span>)); <span class="hljs-comment">//_mm256_srli_epi32(_mm256_and_epi32(dxId256,</span><br>                                    <span class="hljs-comment">//_mm256_set1_epi32(0x1f)), 1);</span><br>    __m256i dx256   = _mm256_add_epi32(dx256A, dx256T1);<br>    __m256i dy256T1 = _mm256_srli_epi32(dxId256, <span class="hljs-number">4</span>);<br>    __m256i dy256   = _mm256_add_epi32(dy256A, dy256T1);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// no _mm256_and_epi32 but has _mm256_and_ps, so bitcast</span><br>    __m256i dx256Tmp1 = _mm256_castps_si256(<br>        _mm256_and_ps(_mm256_castsi256_ps(dxId256), _mm256_castsi256_ps(_mm256_set1_epi32(<span class="hljs-number">0xf</span>))));<br>    __m256i dx256     = _mm256_add_epi32(dx256A, dx256Tmp1);<br>    __m256i dx256Tmp2 = _mm256_srli_epi32(dxId256, <span class="hljs-number">4</span>);<br>    __m256i dy256     = _mm256_add_epi32(dy256A, dx256Tmp2);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    __m256i dxFwMask  = _mm256_cmpgt_epi32(aCsFwS1, dx256);<br>    __m256i dyFhMask  = _mm256_cmpgt_epi32(aCsFhS1, dy256);<br>    __m256i validMask = _mm256_and_si256(dxFwMask, dyFhMask);<br><br>    __m256i gatherIdx = _mm256_slli_epi32(dxId256, <span class="hljs-number">2</span>);<br><br>    __m256  baryVecX = _mm256_i32gather_ps(((f32*)ptrAtpBary), gatherIdx, <span class="hljs-number">4</span>);<br>    __m256  baryVecY = _mm256_i32gather_ps(((f32*)ptrAtpBary) + <span class="hljs-number">1</span>, gatherIdx, <span class="hljs-number">4</span>);<br>    __m256  baryVecZ = _mm256_i32gather_ps(((f32*)ptrAtpBary) + <span class="hljs-number">2</span>, gatherIdx, <span class="hljs-number">4</span>);<br><br>    __m256  atpBxX = _mm256_i32gather_ps(((f32*)ptrAtpBx), gatherIdx, <span class="hljs-number">4</span>);<br>    __m256  atpBxY = _mm256_i32gather_ps(((f32*)ptrAtpBx) + <span class="hljs-number">1</span>, gatherIdx, <span class="hljs-number">4</span>);<br>    __m256  atpBxZ = _mm256_i32gather_ps(((f32*)ptrAtpBx) + <span class="hljs-number">2</span>, gatherIdx, <span class="hljs-number">4</span>);<br><br>    __m256  atpByX = _mm256_i32gather_ps((f32*)ptrAtpBy, gatherIdx, <span class="hljs-number">4</span>);<br>    __m256  atpByY = _mm256_i32gather_ps(((f32*)ptrAtpBy) + <span class="hljs-number">1</span>, gatherIdx, <span class="hljs-number">4</span>);<br>    __m256  atpByZ = _mm256_i32gather_ps(((f32*)ptrAtpBy) + <span class="hljs-number">2</span>, gatherIdx, <span class="hljs-number">4</span>);<br><br>    <span class="hljs-comment">// zCorr</span><br>    __m256  interpolatedDepth =<br>        reqDepth ? _mm256_i32gather_ps((f32*)depthCache, dxId256, <span class="hljs-number">4</span>) : _mm256_setzero_ps();<br>    __m256i tagBufferValid = _mm256_castps_si256(<br>        _mm256_loadu_ps((<span class="hljs-type">const</span> f32*)ptrValid + i)); <span class="hljs-comment">//_mm256_i32gather_epi32(ptrValid, dxId256, 4);</span><br><br>    __m256i idxA     = _mm256_slli_epi32(tagBufferValid, <span class="hljs-number">1</span>);<br>    __m256i idx      = _mm256_add_epi32(tagBufferValid, idxA);<br>    __m256i idxMask  = _mm256_cmpgt_epi32(idx, _mm256_set1_epi32(<span class="hljs-number">-1</span>));<br>    __m256i idxMask2 = _mm256_and_si256(idxMask, validMask);<br><br>    <span class="hljs-comment">// If all invalid, skip</span><br>    <span class="hljs-keyword">if</span> (_mm256_testz_si256(idxMask2, _mm256_set1_epi32(<span class="hljs-number">-1</span>)))<br>        <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">// Mask from idxMask2</span><br>    <span class="hljs-type">int</span> validMaskT[<span class="hljs-number">8</span>], dx[<span class="hljs-number">8</span>], dy[<span class="hljs-number">8</span>], idxT[<span class="hljs-number">8</span>];<br>    f32 interpolatedDepthT[<span class="hljs-number">8</span>];<br>    _mm256_storeu_si256((__m256i*)validMaskT, idxMask2);<br>    _mm256_storeu_ps(interpolatedDepthT, interpolatedDepth);<br>    _mm256_storeu_si256((__m256i*)dx, dx256);<br>    _mm256_storeu_si256((__m256i*)dy, dy256);<br>    _mm256_storeu_si256((__m256i*)idxT, idx);<br><br>    __m256 zCorr = _mm256_rcp_ps(_mm256_add_ps(baryVecX, _mm256_add_ps(baryVecY, baryVecZ)));<br>    baryVecX     = _mm256_mul_ps(baryVecX, zCorr);<br>    baryVecY     = _mm256_mul_ps(baryVecY, zCorr);<br>    baryVecZ     = _mm256_mul_ps(baryVecZ, zCorr);<br><br>    __m256 desiredBaryR[<span class="hljs-number">3</span>];<br>    desiredBaryR[<span class="hljs-number">0</span>] =<br>        _mm256_fmadd_ps(baryVecX, atpBxX, _mm256_fmadd_ps(baryVecY, atpBxY, _mm256_mul_ps(baryVecZ, atpBxZ)));<br>    desiredBaryR[<span class="hljs-number">1</span>] =<br>        _mm256_fmadd_ps(baryVecX, atpByX, _mm256_fmadd_ps(baryVecY, atpByY, _mm256_mul_ps(baryVecZ, atpByZ)));<br>    desiredBaryR[<span class="hljs-number">2</span>] = _mm256_sub_ps(_mm256_set1_ps(<span class="hljs-number">1.0f</span>), _mm256_add_ps(desiredBaryR[<span class="hljs-number">0</span>], desiredBaryR[<span class="hljs-number">1</span>]));<br><br>    <span class="hljs-comment">// convert desiredBary to 16xfloat3</span><br>    f32 desiredBaryX[<span class="hljs-number">8</span>], desiredBaryY[<span class="hljs-number">8</span>], desiredBaryZ[<span class="hljs-number">8</span>];<br>    _mm256_storeu_ps(desiredBaryX, desiredBaryR[<span class="hljs-number">0</span>]);<br>    _mm256_storeu_ps(desiredBaryY, desiredBaryR[<span class="hljs-number">1</span>]);<br>    _mm256_storeu_ps(desiredBaryZ, desiredBaryR[<span class="hljs-number">2</span>]);<br>    _mm256_zeroupper();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (validMaskT[j] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> addr = ptrBaseInd + idxT[j];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; varyCnts; k++)<br>        &#123;<br>            <span class="hljs-keyword">auto</span>        va      = vaPtr[k];<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tmp0    = (va[addr[<span class="hljs-number">0</span>]]);<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tmp1    = (va[addr[<span class="hljs-number">1</span>]]);<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tmp2    = (va[addr[<span class="hljs-number">2</span>]]);<br>            SVector4f   destVec = tmp0 * desiredBaryX[j];<br>            destVec             = <span class="hljs-built_in">Fma</span>(tmp1, desiredBaryY[j], destVec);<br>            ivData[k]           = <span class="hljs-built_in">Fma</span>(tmp2, desiredBaryZ[j], destVec);<br>        &#125;<br>        psEntry-&gt;<span class="hljs-built_in">execute</span>(ivData, coData, &amp;interpolatedDepthT[j]);<br>        ptrCol0-&gt;<span class="hljs-built_in">fillPixelRGBA128ps</span>(dx[j], dy[j], coData-&gt;<span class="hljs-built_in">getVectorizedVal</span>());<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>T:并行计算</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
      <tag>L:SIMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ifrit-v2 过程记录 1: CUDA软件渲染的实现流程</title>
    <link href="/Ibuki/2025/04/23/ifrit-report-1/"/>
    <url>/Ibuki/2025/04/23/ifrit-report-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Ifrit-v2-过程记录-1-CUDA软件渲染的实现流程"><a href="#Ifrit-v2-过程记录-1-CUDA软件渲染的实现流程" class="headerlink" title="Ifrit-v2 过程记录 1: CUDA软件渲染的实现流程"></a>Ifrit-v2 过程记录 1: CUDA软件渲染的实现流程</h1><p>发现自己的脑袋属于一个LRU（Last Recently Used）缓存，最近做的事情就会记得很清楚，之前做的事情就会忘得一干二净。为了防止自己忘记，决定把Ifrit-v2的实现过程记录下来。</p><p>关于Ifrit-v2的所有参考资料和引用，参考对应仓库的ACKNOWLEDGEMENT.md文件</p><h2 id="1-前置内容"><a href="#1-前置内容" class="headerlink" title="1. 前置内容"></a>1. 前置内容</h2><h3 id="1-1-渲染管线"><a href="#1-1-渲染管线" class="headerlink" title="1.1 渲染管线"></a>1.1 渲染管线</h3><p>渲染管线分为四个阶段，分别是应用阶段、几何阶段、光栅化阶段和像素处理阶段。</p><ul><li>应用阶段从显存中读取顶点数据，将其装配为几何图元</li><li>几何阶段对图元进行顶点着色、投影变换、裁剪和屏幕映射。齐次除法后的坐标（NDC坐标）经过屏幕映射后，得到屏幕坐标</li><li>光栅化包括三角形设置、三角形遍历</li><li>像素处理阶段对每个像素进行颜色计算，得到最终的颜色值</li></ul><h4 id="1-1-1-透视正确的重心插值"><a href="#1-1-1-透视正确的重心插值" class="headerlink" title="1.1.1 透视正确的重心插值"></a>1.1.1 透视正确的重心插值</h4><p>对于VS坐标系下的2D空间中的点 $V(x,z)$，其在成像平面上的坐标为$S(u,d)$，则有对应关系:</p><p>$$<br>x &#x3D; \frac{uz}{d}<br>$$<br>对于起始点$V_1(x_1,z_1), S_1(u_1,d)$，终止点$V_2(x_2,z_2), S_2(u_2,d)$，和待插值点$V_t(x_t,z_t), S_t(u_t,d)$，则有：</p><p>$$<br>x_t &#x3D; x_1 + t(x_2 - x_1)<br>$$</p><p>$$<br>z_t &#x3D; z_1 + t(z_2 - z_1)<br>$$</p><p>$$<br>u_t &#x3D; u_1 + s(u_2 - u_1)<br>$$</p><p>即</p><p>$$<br>z_1 + t(z_2 - z_1) &#x3D; \frac{d\left(x_1 + t(x_2 - x_1)\right)}{u_1 + s(u_2 - u_1)}<br>$$</p><p>也就是</p><p>$$<br>z_1 + t(z_2 - z_1) &#x3D; \frac{d\left(\frac{u_1z_1}{d} + t(\frac{u_2z_2}{d} - \frac{u_1z_1}{d})\right)}{u_1 + s(u_2 - u_1)}<br>$$</p><p>$$<br>z_1 + t(z_2 - z_1) &#x3D; \frac{\left(u_1z_1 + t(u_2z_2 - u_1z_1)\right)}{u_1 + s(u_2 - u_1)}<br>$$</p><p>即</p><p>$$<br>s(u_2 - u_1) &#x3D; \frac{u_1z_1 + t(u_2z_2 - u_1z_1)-u_1z_1-u_1t(z_2-z_1)}{z_1 + t(z_2 - z_1)}<br>$$</p><p>$$<br>s(u_2 - u_1) &#x3D; \frac{t(u_2z_2 - u_1z_1)-u_1t(z_2-z_1)}{z_1 + t(z_2 - z_1)}<br>$$</p><p>$$<br>s(u_2 - u_1) &#x3D; \frac{t\left( u_2z_2-u_1z_1-u_1z_2+u_1z_1 \right)}{z_1 + t(z_2 - z_1)}<br>$$</p><p>$$<br>s(u_2 - u_1) &#x3D; \frac{tz_2(u_2-u_1)}{z_1 + t(z_2 - z_1)}<br>$$</p><p>$$<br>s &#x3D; \frac{tz_2}{z_1 + t(z_2 - z_1)}<br>$$</p><p>所以</p><p>$$<br>s(z_1 + t(z_2 - z_1)) &#x3D; tz_2<br>$$</p><p>$$<br>sz_1 + st(z_2 - z_1) &#x3D; tz_2<br>$$</p><p>$$<br>t(s(z_2 - z_1) - z_2) &#x3D; -sz_1<br>$$</p><p>最后得到</p><p>$$<br>t &#x3D; \frac{sz_1}{s(z_1 - z_2) + z_2}<br>$$</p><p>代回原值</p><p>$$<br>z_t &#x3D; z_1 + \frac{sz_1}{s(z_1 - z_2) + z_2}(z_2 - z_1)<br>$$</p><p>$$<br>z_t &#x3D; \frac{sz_1(z_1-z_2)+z_1z_2+sz_1z_2-sz_1^2}{s(z_1 - z_2) + z_2}<br>$$</p><p>$$<br>z_t &#x3D; \frac{z_1z_2}{s(z_1 - z_2) + z_2}<br>$$</p><p>$$<br>z_t &#x3D; \frac{1}{s(\frac{1}{z_2}-\frac{1}{z_1}) + \frac{1}{z_1}}<br>$$</p><p>对于任意值$A$</p><p>$$<br>A_t &#x3D; A_1 + \frac{sz_1}{s(z_1 - z_2) + z_2}(A_2 - A_1)<br>$$</p><p>$$<br>A_t &#x3D; \frac{A_1s(z_1-z_2)+A_1z_2+sz_1A_2-sz_1A_1}{s(z_1 - z_2) + z_2}<br>$$</p><p>$$<br>A_t &#x3D; \frac{A_1z_2-sA_1z_2+sz_1A_2}{s(z_1 - z_2) + z_2}<br>$$</p><p>$$<br>A_t &#x3D; \frac{A_1z_2(1-s)+A_2z_1s}{s(z_1 - z_2) + z_2}<br>$$</p><p>$$<br>A_t &#x3D; \frac{\frac{A_1}{z_1}(1-s)+\frac{A_2}{z_2}s}{\frac{1}{z_1}(1-s)+\frac{1}{z_2}s}<br>$$</p><p>考虑空间坐标A,B,C的投影和某一点的屏幕上的重心坐标$(u,v)$</p><p>$$<br>CQ &#x3D; uCA + vCB<br>$$</p><p>设$AD&#x3D;kAB$，D在AB上，则</p><p>$$<br>z_d &#x3D; \frac{1}{\frac{1}{z_A}+k(\frac{1}{z_B}-\frac{1}{z_A})}<br>$$</p><p>设$CQ &#x3D; pCD$，则</p><p>$$<br>z_q &#x3D; \frac{1}{\frac{1}{z_C}+p(\frac{1}{z_A}+k(\frac{1}{z_B}-\frac{1}{z_A})-\frac{1}{z_C})}<br>$$</p><p>$$<br>z_q &#x3D; \frac{1}{(1-p)\frac{1}{z_C}+p(1-k)\frac{1}{z_A}+pk\frac{1}{z_B}}<br>$$</p><p>考虑到</p><p>$$<br>p(CA+k(CB-CA))&#x3D;uCA+vCB<br>$$</p><p>$$<br>pCA-pkCA +pkCB &#x3D; uCA+vCB<br>$$</p><p>所以有 $pk&#x3D;v, p(1-k)&#x3D;u$，带入，得到</p><p>$$<br>z_q &#x3D; \frac{1}{(1-u-v)\frac{1}{z_C}+u\frac{1}{z_A}+v\frac{1}{z_B}}<br>$$</p><h3 id="1-2-CUDA"><a href="#1-2-CUDA" class="headerlink" title="1.2 CUDA"></a>1.2 CUDA</h3><h4 id="1-2-1-restrict-指针"><a href="#1-2-1-restrict-指针" class="headerlink" title="1.2.1 restrict 指针"></a>1.2.1 restrict 指针</h4><p>restrict指针是一个C99的关键字（虽然MSVC的C++和CUDA里也能用），表示该指针所指向的内存区域不会被其他指针访问。这样编译器就可以对该内存区域进行更好的优化。</p><h2 id="2-CUDA-软光栅流程"><a href="#2-CUDA-软光栅流程" class="headerlink" title="2. CUDA 软光栅流程"></a>2. CUDA 软光栅流程</h2><h3 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h3><p>直接一个线程对应一个顶点，执行顶点着色器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cuda">IFRIT_KERNEL void vertexProcessingKernel(<br>    VertexShader* vertexShader,<br>    uint32_t vertexCount,<br>    char* IFRIT_RESTRICT_CUDA dVertexBuffer,<br>    TypeDescriptorEnum* IFRIT_RESTRICT_CUDA dVertexTypeDescriptor,<br>    float4* IFRIT_RESTRICT_CUDA dVaryingBuffer,<br>    float4* IFRIT_RESTRICT_CUDA dPosBuffer<br>) &#123;<br>    const auto globalInvoIdx = blockIdx.x * blockDim.x + threadIdx.x;<br>    if (globalInvoIdx &gt;= vertexCount) return;<br>    const auto numAttrs = csAttributeCounts;<br>    const auto numVaryings = csVaryingCounts;<br><br>    const void* vertexInputPtrs[CU_MAX_ATTRIBUTES];<br>    float4* varyingOutputPtrs[CU_MAX_VARYINGS];<br><br>    for (int i = 0; i &lt; numAttrs; i++) &#123;<br>        vertexInputPtrs[i] = globalInvoIdx * csTotalVertexOffsets + dVertexBuffer + csVertexOffsets[i];<br>    &#125;<br>    for (int i = 0; i &lt; numVaryings; i++) &#123;<br>        varyingOutputPtrs[i] = dVaryingBuffer + globalInvoIdx * numVaryings + i;<br>    &#125;<br>    vertexShader-&gt;execute(vertexInputPtrs, (Vector4f*)&amp;dPosBuffer[globalInvoIdx], (Vector4f**)varyingOutputPtrs);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-裁剪、剔除和图元生成"><a href="#2-2-裁剪、剔除和图元生成" class="headerlink" title="2.2 裁剪、剔除和图元生成"></a>2.2 裁剪、剔除和图元生成</h3><p>一个线程处理一个三角形，首先先从Index Buffer中拿到三角形的三个顶点。</p><p>之后考虑齐次裁剪，这里使用直接VS输出的坐标（等待标准化）。对于相邻两个顶点，如果w分量符号不同，则进入剔除流程，求两个点在w&#x3D;Near平面上的交点，将该点加入顶点列表，之后按序组装裁剪后的三角形。</p><blockquote><p> 这里我只使用了近平面裁剪，因为后续光栅化算法是Tile-based的，因此不存在Viewport之外的Tile。产生了更多的三角形反而增加不必要的Triangle-Tile的相交测试，徒增开销。另外，更多的裁剪会增加Local Memory（实际上是访存开销最大的Global Memory）的使用；如果放Shared Memory又会降低Occupancy。权衡考虑，我只使用近平面裁剪。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cuda">float4 vSrc[3] = &#123; v1,v2,v3 &#125;;<br>for (int j = 0; j &lt; 3; j++) &#123;<br>    auto curNid = (j + 1) % 3;<br>    auto pnPos = vSrc[curNid];<br>    auto npn = -pnPos.w;<br><br>    float3 pnBary = &#123; 0,0,0 &#125;;<br>    if (j == 0) pnBary.y = 1;<br>    if (j == 1) pnBary.z = 1;<br>    if (j == 2) pnBary.x = 1;<br><br>    if IF_CONSTEXPR (!CU_OPT_HOMOGENEOUS_DISCARD) &#123;<br>        if (npc * npn &lt; 0) &#123;<br>            float numo = pc.pos.w;<br>            float deno = -(pnPos.w - pc.pos.w);<br>            float t = (-1e-3f + numo) / deno;<br>            float4 intersection = Lerp(pc.pos, pnPos, t);<br>            float3 barycenter = Lerp(pc.barycenter, pnBary, t);<br><br>            TileRasterClipVertexCUDA newp;<br>            newp.barycenter = barycenter;<br>            newp.pos = intersection;<br>            retd[retdTriCnt + retOffset - 3] = newp;<br>            retdIndex[retCnt + retIdxOffset] = retdTriCnt;<br>            retCnt++;<br>            retdTriCnt++;<br>        &#125;<br>    &#125;<br><br>    if (npn &lt; 0) &#123;<br>        retdIndex[retCnt + retIdxOffset] = curNid;<br>        retCnt++;<br>    &#125;<br>    npc = npn;<br>    pc.pos = pnPos;<br>    pc.barycenter = pnBary;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>完成后，将所有三角形转换到NDC空间，计算三角形包围盒，剔除不在视窗范围内的三角形。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cuda">IFRIT_DEVICE bool devViewSpaceClip(float4 v1, float4 v2, float4 v3) &#123;<br>    auto maxX = max(v1.x, max(v2.x, v3.x));<br>    auto maxY = max(v1.y, max(v2.y, v3.y));<br>    auto minX = min(v1.x, min(v2.x, v3.x));<br>    auto minY = min(v1.y, min(v2.y, v3.y));<br>    auto isIllegal = maxX &lt; 0.0f || maxY &lt; 0.0f || minX &gt; 1.0f || minY &gt; 1.0f;<br>    return isIllegal;<br>&#125;<br></code></pre></td></tr></table></figure><p>在NDC空间中，计算三角形的有向面积，如果该面积小于0，进行背面剔除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cuda">IFRIT_DEVICE bool devTriangleCull(float4 v1, float4 v2, float4 v3) &#123;<br>    float d1 = (v1.x * (v2.y - v3.y));<br>    float d2 = (v2.x * (v3.y - v1.y));<br>    float d3 = (v3.x * (v1.y - v2.y));<br>    return (d1 + d2 + d3) &gt;= 0.0f;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不覆盖任何采样点的小三角形，进行Contribution Culling，剔除小三角形。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cuda">IF_CONSTEXPR auto enableSmallPrimitiveCull = CU_OPT_SMALL_PRIMITIVE_CULL &amp;&amp; !tpMsaaEnabled;<br>if IF_CONSTEXPR (enableSmallPrimitiveCull) &#123;<br>    float4 bbox;<br>    GeneralFunction::devGetBBox(dv1, dv2, dv3, bbox);<br>    bbox.x = bbox.x * csFrameWidth;<br>    bbox.z = bbox.z * csFrameWidth;<br>    bbox.y = bbox.y * csFrameHeight;<br>    bbox.w = bbox.w * csFrameHeight;<br>    if (round(bbox.x) == round(bbox.z) || round(bbox.w) == round(bbox.y)) &#123;<br>        continue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将通过测试的三角形加入列表。</p><h3 id="2-3-光栅化"><a href="#2-3-光栅化" class="headerlink" title="2.3 光栅化"></a>2.3 光栅化</h3><h4 id="2-3-1-测试参数预生成"><a href="#2-3-1-测试参数预生成" class="headerlink" title="2.3.1 测试参数预生成"></a>2.3.1 测试参数预生成</h4><p>后续我们需要测试每一个三角形的边对于某个点而言，在里侧或者外侧。对于$A(a,b),B(c,d)$，测试点的内外可以通过向量积来判断：<br>$$<br>F &#x3D; sign(((C-A) \times (B-A)) &#x3D; sign( (x-a)(d-b) - (y-b)(c-a) )<br>$$</p><p>拆开上述方程，可以写为：</p><p>$$<br>f(x,y) &#x3D; x(d-b) - y(c-a) +bc - ad<br>$$</p><p>实际上我们取得的(x,y)是整数格点的坐标，而上式所需的(x,y)是UV&#x2F;NDC坐标，因此为了省略浮点除法运算，可以将A和B的坐标转换到当前坐标系下。最后得到9个坐标，为了后续Kernel的Memory Coalescing，我们将其Pack到2个float4和一个float中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cuda">const float sV2V1y = dv2.y - dv1.y;<br>const float sV2V1x = dv1.x - dv2.x;<br>const float sV3V2y = dv3.y - dv2.y;<br>const float sV3V2x = dv2.x - dv3.x;<br>const float sV1V3y = dv1.y - dv3.y;<br>const float sV1V3x = dv3.x - dv1.x;<br>dAtriEdgeCoefs1Aligned[globalInvo] = &#123;<br>    (float)(sV2V1y)*frameHeight,<br>    (float)(sV2V1x)*frameWidth ,<br>    (float)(-dv2.x * frameWidth * dv1.y * frameHeight + dv1.x * frameWidth * dv2.y * frameHeight), //+deps<br>    (float)(sV3V2y)*frameHeight<br>&#125;;<br>dAtriEdgeCoefs2Aligned[globalInvo] = &#123;<br>    (float)(sV3V2x)*frameWidth ,<br>    (float)(-dv3.x * frameWidth * dv2.y * frameHeight + dv2.x * frameWidth * dv3.y * frameHeight), //+deps<br>    (float)(sV1V3y)*frameHeight,<br>    (float)(sV1V3x)*frameWidth ,<br>&#125;;<br>dAtriEdgeCoefs3Aligned[globalInvo] = (float)(-dv1.x * frameWidth * dv3.y * frameHeight + dv3.x * frameWidth * dv1.y * frameHeight); //+deps<br></code></pre></td></tr></table></figure><p>然后对于三角形内某点$P(x,y)$, 我们计算重心坐标$(u,v)$, 其中<br>$$<br>u &#x3D; PB \times CB, v&#x3D; PC \times BA<br>$$</p><p>对于$u$，结果可以写为<br>$$<br>u &#x3D; (x-x_b)(y_c-y_b) - (y-y_b)(x_c-x_b) &#x3D; (y_c-y_b)x - (x_c-x_b)y + (x_cy_b-x_by_c)<br>$$</p><p>对于$v$，结果可以写为<br>$$<br>v &#x3D; (x-x_c)(y_a-y_c) - (y-y_c)(x_a-x_c) &#x3D; (y_a-y_c)x - (x_a-x_c)y + (x_ay_c-x_cy_a)<br>$$</p><p>同样地，避免除法，预计算$1&#x2F;w$，同时转换到整数格点的坐标空间中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cuda">float4 f3 = &#123; (float)(sV2V1y * ar) * invFrameWidth, (float)(sV2V1x * ar) * invFrameHeight,(float)((-dv1.x * sV2V1y - dv1.y * sV2V1x) * ar) &#125;;<br>float4 f1 = &#123; (float)(sV3V2y * ar) * invFrameWidth, (float)(sV3V2x * ar) * invFrameHeight,(float)((-dv2.x * sV3V2y - dv2.y * sV3V2x) * ar) &#125;;<br>float4 f2 = &#123; (float)(sV1V3y * ar) * invFrameWidth, (float)(sV1V3x * ar) * invFrameHeight,(float)((-dv3.x * sV1V3y - dv3.y * sV1V3x) * ar) &#125;;<br><br>float v1 = dv1.z * f1.x + dv2.z * f2.x + dv3.z * f3.x;<br>float v2 = dv1.z * f1.y + dv2.z * f2.y + dv3.z * f3.y;<br>float v3 = dv1.z * f1.z + dv2.z * f2.z + dv3.z * f3.z;<br><br>f1.x *= dv1.w;<br>f1.y *= dv1.w;<br>f1.z *= dv1.w;<br><br>f2.x *= dv2.w;<br>f2.y *= dv2.w;<br>f2.z *= dv2.w;<br><br>f3.x *= dv3.w;<br>f3.y *= dv3.w;<br>f3.z *= dv3.w;<br>dAtriInterpolBase1Aligned[globalInvo] = &#123; f1.x,f1.y,f1.z,f2.x &#125;;<br>dAtriInterpolBase2Aligned[globalInvo] = &#123; f2.y,f2.z,f3.x,f3.y &#125;;<br>dAtriInterpolBase3[globalInvo] = f3.z;<br><br>dAtriDepthVal12[globalInvo].x = v1;<br>dAtriDepthVal12[globalInvo].y = v2;<br>dAtriDepthVal3[globalInvo] = v3;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-Primary-Binner"><a href="#2-3-2-Primary-Binner" class="headerlink" title="2.3.2 Primary Binner"></a>2.3.2 Primary Binner</h4><p>后续的流程基于CUDA的Dynamic Parallism进行，即一个Kernel调用另一个Kernel。所有的Kernel<br>参数都在GPU端计算完成，不需要回传CPU发起Kernel调用，这类似于Indirect Draw。</p><p>显然三角形的大小不一致，大三角形覆盖更多的Tile，而小三角形覆盖的Tile更少。对于Tile我们需要维护一个待处理的三角形列表，显然混合处理大小三角形会导致严重的Stall，同一个Warp里小三角形等待大三角形的Binning步骤，这个是不太合理的。项目中使用了两个不同的设备端函数<code>devExecuteBinnerLargeTile</code>和<code>devExecuteBinner</code>分别处理大三角形和小三角形。</p><p>之后将三角形加入Tile列表，具体流程如下：对于每一个三角形和Tile，测试产生三种结果Accept，Reject和Partial。对于Accept的三角形，直接加入Tile列表；Reject的三角形直接丢弃；Partial的三角形则需要进行进一步的处理。</p><ul><li>Accept: 该Tile完全包含该三角形。对三条边给出的Accept Proposal进行测试，完全通过。</li><li>Reject：该Tile完全不包含该三角形。对三条边给出的Reject Proposal进行测试，任意一个不通过。</li><li>Partial：该Tile部分包含该三角形。剩余测试结果归入该类。</li></ul><p>上述测试的思路如下：</p><ul><li><p>Accept Proposal: 对于屏幕空间三角形的任意一条边，计算其屏幕空间朝外的法向量，找到该法向量定义的距离最近的Tile的Corner（例如三角形法向量朝向左上，则AP的测试Proposal为Tile的右下格点）。如果该格点在三角形内部，这一个Proposal测试通过，当3个Proposal都通过时，Tile完全被包含在三角形内。</p></li><li><p>Reject Proposal: 对于屏幕空间三角形的任意一条边，计算其屏幕空间朝外的法向量，找到该法向量定义的距离最远的Tile的Corner（例如三角形法向量朝向左上，则AP的测试Proposal为Tile的左上格点）。如果该格点在三角形外部，这一个Proposal测试被拒绝，当任意一个Proposal测试被拒绝时，Tile完全不被包含在三角形内。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cuda"><br>IFRIT_DEVICE void devGetAcceptRejectCoords(float4 edgeCoefs[3], int chosenCoordTR[3], int chosenCoordTA[3]) &#123;<br>    IF_CONSTEXPR const int VLB = 0, VLT = 1, VRT = 3, VRB = 2;<br>    for (int i = 0; i &lt; 3; i++) &#123;<br>        bool normalRight = edgeCoefs[i].x &lt; 0;<br>        bool normalDown = edgeCoefs[i].y &lt; 0;<br>        if (normalRight) &#123;<br>            if (normalDown) &#123;<br>                chosenCoordTR[i] = VRB;<br>                chosenCoordTA[i] = VLT;<br>            &#125;<br>            else &#123;<br>                chosenCoordTR[i] = VRT;<br>                chosenCoordTA[i] = VLB;<br>            &#125;<br>        &#125;<br>        else &#123;<br>            if (normalDown) &#123;<br>                chosenCoordTR[i] = VLB;<br>                chosenCoordTA[i] = VRT;<br>            &#125;<br>            else &#123;<br>                chosenCoordTR[i] = VLT;<br>                chosenCoordTA[i] = VRB;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于Large Binner而言，我们遍历当前三角形BBox所覆盖的Tile，对上述Tile执行上述测试。将三角形原子写入Tile列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cuda">for(...)<br>    if (criteriaTR != 3)<br>        continue;<br>    auto tileLargeId = y * CU_MAX_LARGE_BIN_X + x;<br>    if (criteriaTA == 3) &#123;<br>        int x = atomicAdd(&amp;dCoverQueueSuperTileFullM3TotlCands, 1);<br>        dCoverQueueSuperTileFullM3Buffer[x].x = primitiveId;<br>        dCoverQueueSuperTileFullM3Buffer[x].y = tileLargeId;<br><br>        atomicAdd(&amp;dCoverQueueSuperTileFullM3Size[tileLargeId], 1);<br>    &#125;<br>    else &#123;<br>        auto plId = atomicAdd(&amp;dCoverPrimsLargeTileCounter, 1);<br>        dCoverPrimsTileLarge[plId].x = primitiveId;<br>        dCoverPrimsTileLarge[plId].y = tileLargeId;<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于Small Binner和Large Binner的后处理，我们将结果分类。对于Accept三角形直接写<code>dCoverPrim</code>，对于Partial的写<code>dRasterQueueWorklistPrimTile</code>给Second Rasterizer处理。</p><h4 id="2-3-3-Second-Rasterizer"><a href="#2-3-3-Second-Rasterizer" class="headerlink" title="2.3.3 Second Rasterizer"></a>2.3.3 Second Rasterizer</h4><p>Second Rasterizer处理部分被三角形覆盖的Tiles，每一个Proposal包括一个Triangle ID和Tile ID。每一个TG中的Z大小负责处理这个Tile Proposal中的所有Subtile，按照和Primary Binner相同的方式测试。测试成功将写入新的List中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cuda">if (criteriaTR == 3) &#123;<br>    int x = atomicAdd(&amp;dSecondBinnerCandCounter, 1);<br>    dSecondBinnerPendingPrim[x].x = primitiveSrcId;<br>    dSecondBinnerPendingPrim[x].y = tileId * CU_MAX_SUBTILES_PER_TILE + subTileId;<br>    atomicAdd(&amp;dSecondBinnerFinerBufferSize[tileId * CU_MAX_SUBTILES_PER_TILE + subTileId], csMsaaSampleBits);<br>&#125;<br></code></pre></td></tr></table></figure><p>后续由Finer Second Binner 处理像素级别的相交测试，这里相交结果使用位运算表示。默认一个Subtile有16个子像素，使用一个uint32_t表示16个子像素的相交结果。每一个子像素的ID为<code>(x * 4 + y)</code>，其中x和y分别为子像素在Subtile中的坐标。另外对于一个Msaa采样点，使用一个独立的uint32_t表示，高位写入当前采样点ID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cuda">for (int i2 = 0; i2 &lt; CU_EXPERIMENTAL_PIXELS_PER_SUBTILE; i2++) &#123;<br>    bool accept1 = (criteriaX[0] + criteriaY[0]) &lt; edgeCoefs[0].z + dEps;<br>    bool accept2 = (criteriaX[1] + criteriaY[1]) &lt; edgeCoefs[1].z + dEps;<br>    bool accept3 = (criteriaX[2] + criteriaY[2]) &lt; edgeCoefs[2].z + dEps;<br><br>    int cond = (accept1 &amp;&amp; accept2 &amp;&amp; accept3);<br>    dsMask[i2] |= (cond &lt;&lt; k);<br><br>    if ((i2 + 1) % CU_EXPERIMENTAL_SUBTILE_WIDTH == 0) &#123;<br>        mask |= (cond &lt;&lt; i2);<br>        criteriaY[0] += edgeCoefs[0].y;<br>        criteriaY[1] += edgeCoefs[1].y;<br>        criteriaY[2] += edgeCoefs[2].y;<br>        criteriaX[0] = rsX1;<br>        criteriaX[1] = rsX2;<br>        criteriaX[2] = rsX3;<br>    &#125;<br>    else &#123;<br>        mask |= (cond &lt;&lt; i2); <br>        criteriaX[0] += edgeCoefs[0].x;<br>        criteriaX[1] += edgeCoefs[1].x;<br>        criteriaX[2] += edgeCoefs[2].x;<br>    &#125;<br>&#125;<br><br>if (mask == 0) continue;<br>int xid = xidSrc;<br>int pw = atomicAdd(&amp;dSecondBinnerFinerBufferCurInd[xid], 1);<br>dSecondBinnerFinerBuffer[pw].x = mask | (k &lt;&lt; CU_EXPERIMENTAL_PIXELS_PER_SUBTILE);<br>dSecondBinnerFinerBuffer[pw].y = primitiveSrcId;<br>dSecondBinnerFinerBufferSortKeys[pw] = dAtriOriginalPrimId[primitiveSrcId];<br></code></pre></td></tr></table></figure><h4 id="2-3-4-排序"><a href="#2-3-4-排序" class="headerlink" title="2.3.4 排序"></a>2.3.4 排序</h4><p>这里直接使用一个简单的堆排序，速度不行。默认未开启Alpha Blending，并且没有Depth Write，以及未强制保持渲染顺序的情况下，排序Kernel不会被调用。完成排序后，光栅化步骤结束。</p><h3 id="2-4-片元着色和Alpha混合"><a href="#2-4-片元着色和Alpha混合" class="headerlink" title="2.4 片元着色和Alpha混合"></a>2.4 片元着色和Alpha混合</h3><p>片元着色Kernel一次性处理一个Tile的16x16的像素。其中DimX大小为4，负责一个Quad中的2x2个像素（这样强制一个Quad中的4个像素在一个Warp中，后续计算ddx和ddy不需要任何的同步操作），剩余DimY和DimZ大小为8.</p><p>此后先生成当前线程负责SubTile中所在像素的BitMask<code>dwMask</code>，和该像素对应的Quad的4个像素的BitMask<code>dsMask</code>。之后取出Finer Second Binner在当前SubTile下的某个Triangle，比较光栅化结果Mask是否与<code>dsMask</code>重叠，产生两种结果：</p><ul><li>Sampling Invocation: <code>dwMask</code>与Mask的交集不为0，表示当前像素被三角形覆盖，需要进行片元着色</li><li>Helper Invocation: <code>dwMask</code>与Mask的交集为0，表示当前像素不被三角形覆盖，不需要进行片元着色，但为了保证着色器导数的正确性，仍然需要执行片元着色器。该Invocation的结果会被丢弃。</li></ul><p>在此之前，如果没有Alpha Blending和Depth Write，可以先执行一个Depth Prepass，先执行Early Z，然后将结果和待着色片元分别写入深度缓冲和Tag Buffer中。之后拿Tag Buffer的结果执行PS。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cuda">auto zPrePass = [&amp;](int primId,int subsample) &#123;<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_NEVER) return;<br>    float interpolatedDepth;<br>    float2 v12 = dAtriDepthVal12[primId];<br>    float v3 = dAtriDepthVal3[primId];<br>    interpolatedDepth = v12.x * pDx + v12.y * pDy + v3;<br>    <br>    auto&amp; localDepthVal = (subsample &lt; 0) ? localDepthBuffer : localDepthBufferSubsample[subsample];<br>    auto&amp; localCandPrim = (subsample &lt; 0) ? candidatePrim : candidatePrimSubsample[subsample];<br><br>#define PLACE_COND(cond) if ((cond)) &#123; localDepthVal = interpolatedDepth; localCandPrim = primId;&#125;<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_LESS) PLACE_COND(interpolatedDepth &lt; localDepthVal);<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_LESS_OR_EQUAL)PLACE_COND(interpolatedDepth &lt;= localDepthVal);<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_EQUAL) PLACE_COND(interpolatedDepth == localDepthVal);<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_GREATER) PLACE_COND(interpolatedDepth &gt; localDepthVal);<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_GREATER_OR_EQUAL) PLACE_COND(interpolatedDepth &gt;= localDepthVal);<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_NOT_EQUAL) PLACE_COND(interpolatedDepth != localDepthVal);<br>    if IF_CONSTEXPR (tpDepthFunc == IF_COMPARE_OP_ALWAYS) &#123;<br>        auto&amp; localOrgPrimIdRef = (subsample &lt; 0) ? localOrgPrimId : localOrgPrimIdSubsample[subsample];<br>        if (dAtriOriginalPrimId[primId] &lt; localOrgPrimIdRef) &#123;<br>            localDepthVal = interpolatedDepth;<br>            localOrgPrimIdRef = dAtriOriginalPrimId[primId];<br>            localCandPrim = primId;<br>        &#125;<br>    &#125;<br>#undef PLACE_COND<br>    if IF_CONSTEXPR (CU_PROFILER_OVERDRAW) &#123;<br>        atomicAdd(&amp;dOverZTestCounter, 1);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>执行PS前，进行插值，之后执行PS。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cuda">candidateBary[0] = (f1.x * pDx + f1.y * pDy + f1.z);<br>candidateBary[1] = (f2.x * pDx + f2.y * pDy + f2.z);<br>candidateBary[2] = (f3.x * pDx + f3.y * pDy + f3.z);<br>float zCorr = 1.0f / (candidateBary[0] + candidateBary[1] + candidateBary[2]);<br>candidateBary[0] *= zCorr;<br>candidateBary[1] *= zCorr;<br>candidateBary[2] *= zCorr;<br><br>float desiredBary[3];<br>desiredBary[0] = candidateBary[0] * b12.x + candidateBary[1] * b12.z + candidateBary[2] * b3.x;<br>desiredBary[1] = candidateBary[0] * b12.y + candidateBary[1] * b12.w + candidateBary[2] * b3.y;<br>desiredBary[2] = 1.0f - (desiredBary[0] + desiredBary[1]);<br></code></pre></td></tr></table></figure><p>如果启用了Alpha Blending，则根据当前Triangle在这个Pixel中采样占比着色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cuda">auto mxSrcX = (blendParam.s.x + blendParam.s.y * (1 - srcRgba.w) + blendParam.s.z * (1 - dstRgba.w)) * (1-blendParam.s.w);<br>auto mxDstX = (blendParam.d.x + blendParam.d.y * (1 - srcRgba.w) + blendParam.d.z * (1 - dstRgba.w)) * (1-blendParam.d.w);<br>auto mxSrcA = (blendParamAlpha.s.x + blendParamAlpha.s.y * (1 - srcRgba.w) + blendParamAlpha.s.z * (1 - dstRgba.w)) * (1-blendParamAlpha.s.w);<br>auto mxDstA = (blendParamAlpha.d.x + blendParamAlpha.d.y * (1 - srcRgba.w) + blendParamAlpha.d.z * (1 - dstRgba.w)) * (1-blendParamAlpha.d.w);<br><br>mixRgba.x = dstRgba.x * mxDstX + srcRgba.x * mxSrcX;<br>mixRgba.y = dstRgba.y * mxDstX + srcRgba.y * mxSrcX;<br>mixRgba.z = dstRgba.z * mxDstX + srcRgba.z * mxSrcX;<br>mixRgba.w = dstRgba.w * mxDstA + srcRgba.w * mxSrcA;<br><br>col0[pixelYS * csFrameWidth + pixelXS] = mixRgba;<br>dDepthBuffer[pixelYS * csFrameWidth + pixelXS] = tDepth;<br></code></pre></td></tr></table></figure><h2 id="3-部分特性实现"><a href="#3-部分特性实现" class="headerlink" title="3. 部分特性实现"></a>3. 部分特性实现</h2><h3 id="3-1-双缓冲和流重叠"><a href="#3-1-双缓冲和流重叠" class="headerlink" title="3.1 双缓冲和流重叠"></a>3.1 双缓冲和流重叠</h3><p>双缓冲的实现是通过CUDA的流来实现的。当前一帧的结果正在回传时，我们能先渲染下一帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cuda">std::chrono::high_resolution_clock::time_point end2 = std::chrono::high_resolution_clock::now();<br>if (args.doubleBuffering) &#123;<br>    for (int i = 0; i &lt; args.dHostColorBufferSize; i++) &#123;<br>        if IF_CONSTEXPR (CU_PROFILER_ENABLE_MEMCPY) &#123;<br>            cudaMemcpyAsync(args.hColorBuffer[i], args.dLastColorBuffer[i], Impl::hsFrameWidth * Impl::hsFrameHeight * sizeof(Vector4f), cudaMemcpyDeviceToHost, copyStream);<br>        &#125;<br>    &#125;<br>&#125;<br>cudaStreamSynchronize(computeStream);<br>if (args.doubleBuffering) &#123;<br>    cudaStreamSynchronize(copyStream);<br>&#125;<br>if (!args.doubleBuffering) &#123;<br>    for (int i = 0; i &lt; args.dHostColorBufferSize; i++) &#123;<br>        cudaMemcpy(args.hColorBuffer[i], args.dHostColorBuffer[i], Impl::hsFrameWidth * Impl::hsFrameHeight * sizeof(Vector4f), cudaMemcpyDeviceToHost);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>T:并行计算</tag>
      
      <tag>T:图形学</tag>
      
      <tag>L:CUDA</tag>
      
      <tag>L:C++</tag>
      
      <tag>P:Ifrit-v2</tag>
      
      <tag>T:几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
